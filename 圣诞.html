<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>âœ¨ åœ£è¯å¿«ä¹ âœ¨</title>
    <style>
        /* é‡ç½®æ ·å¼ï¼Œç¡®ä¿è·¨å¹³å°å…¼å®¹ */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            -webkit-user-select: none;
            user-select: none;
            touch-action: manipulation;
        }
        
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #000;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
        }
        
        body {
            position: fixed;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, #0a1f3d 0%, #000 100%);
            color: white;
            -webkit-overflow-scrolling: touch;
        }
        
        .container {
            position: relative;
            width: 100%;
            height: 100%;
        }
        
        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: block;
            z-index: 1;
            touch-action: none;
        }
        
        /* æ ‡é¢˜ - å›ºå®šåœ¨é¡¶éƒ¨ */
        .title {
            position: fixed;
            top: env(safe-area-inset-top, 10px);
            left: 0;
            right: 0;
            z-index: 3;
            text-align: center;
            padding: 10px 20px;
            background: rgba(0, 20, 0, 0.6);
            border-bottom: 2px solid rgba(255, 215, 0, 0.3);
        }
        
        .title h1 {
            font-size: 24px;
            background: linear-gradient(45deg, #ff0000, #ff9900, #ffff00, #00ff00);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            color: transparent;
            margin-bottom: 5px;
        }
        
        .title p {
            font-size: 14px;
            color: #90EE90;
        }
        
        /* æ§åˆ¶é¢æ¿ - æ”¾åœ¨åº•éƒ¨ */
        .controls {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            z-index: 3;
            background: rgba(0, 30, 0, 0.95);
            padding: 15px;
            padding-bottom: calc(15px + env(safe-area-inset-bottom, 0px));
            border-top: 2px solid gold;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            max-height: 40vh;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }
        
        .btn {
            background: linear-gradient(145deg, #006400, #32CD32);
            color: white;
            border: none;
            padding: 14px 20px;
            border-radius: 30px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            min-width: 160px;
            min-height: 50px;
            -webkit-appearance: none;
            transition: transform 0.1s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        .btn:active {
            transform: scale(0.95);
        }
        
        .btn.active {
            background: linear-gradient(145deg, #FF4500, #FF0000);
            box-shadow: 0 0 20px rgba(255, 69, 0, 0.7);
        }
        
        /* è®¡æ•°å™¨ - å³ä¸Šè§’ */
        .counter {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 3;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 15px;
            border-radius: 10px;
            border: 1px solid gold;
            font-size: 14px;
            color: #00ff00;
            text-align: center;
        }
        
        /* ä¿¡æ¯é¢æ¿ - å·¦ä¸Šè§’ */
        .tree-info {
            position: fixed;
            top: 80px;
            left: 20px;
            z-index: 3;
            background: rgba(0, 0, 0, 0.7);
            padding: 12px;
            border-radius: 10px;
            border: 1px solid cyan;
            max-width: 200px;
            font-size: 14px;
        }
        
        .tree-info h3 {
            color: cyan;
            margin-bottom: 8px;
            text-align: center;
            font-size: 16px;
        }
        
        .tree-info ul {
            list-style: none;
            padding-left: 0;
        }
        
        .tree-info li {
            margin: 4px 0;
            color: #90EE90;
            font-size: 13px;
        }
        
        /* ç¥ç¦è¯­ - ä¸­é—´é¡¶éƒ¨ */
        .message {
            position: fixed;
            top: 120px;
            left: 0;
            right: 0;
            text-align: center;
            z-index: 3;
            font-size: 18px;
            color: gold;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.8);
            padding: 0 20px;
            animation: messagePulse 2s ease-in-out infinite;
        }
        
        @keyframes messagePulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(1.05); }
        }
        
        /* æŠ˜å æŒ‰é’® */
        .toggle-controls {
            position: fixed;
            bottom: 10px;
            right: 20px;
            z-index: 4;
            background: rgba(255, 215, 0, 0.9);
            color: #000;
            border: none;
            padding: 10px 15px;
            border-radius: 20px;
            font-size: 14px;
            cursor: pointer;
            font-weight: bold;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.3);
            min-height: 40px;
        }
        
        /* åŠ è½½åŠ¨ç”» */
        .loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: opacity 0.5s ease;
        }
        
        .loading-content {
            text-align: center;
            padding: 20px;
        }
        
        .spinner {
            width: 50px;
            height: 50px;
            border: 4px solid rgba(255, 215, 0, 0.3);
            border-top: 4px solid gold;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* å“åº”å¼è®¾è®¡ */
        @media (max-width: 768px) {
            .title h1 {
                font-size: 20px;
            }
            
            .controls {
                padding: 10px;
                gap: 8px;
            }
            
            .btn {
                min-width: 140px;
                padding: 12px 16px;
                font-size: 15px;
                min-height: 44px;
            }
            
            .counter {
                top: 15px;
                right: 15px;
                font-size: 13px;
            }
            
            .tree-info {
                top: 70px;
                left: 15px;
                max-width: 180px;
                font-size: 13px;
            }
            
            .message {
                top: 100px;
                font-size: 16px;
            }
        }
        
        @media (max-width: 480px) {
            .controls {
                max-height: 50vh;
                padding-bottom: calc(10px + env(safe-area-inset-bottom, 0px));
            }
            
            .btn {
                min-width: 130px;
                padding: 10px 14px;
                font-size: 14px;
            }
            
            .title h1 {
                font-size: 18px;
            }
            
            .tree-info {
                display: none;
            }
            
            .toggle-controls {
                bottom: 5px;
                right: 10px;
                font-size: 12px;
                padding: 8px 12px;
            }
        }
        
        /* æ¨ªå±æ¨¡å¼ä¼˜åŒ– */
        @media (orientation: landscape) and (max-height: 600px) {
            .controls {
                max-height: 50vh;
            }
            
            .title {
                padding: 8px;
            }
            
            .title h1 {
                font-size: 18px;
                margin-bottom: 0;
            }
            
            .message {
                top: 80px;
                font-size: 16px;
            }
        }
        
        /* iOSç‰¹å®šä¼˜åŒ– */
        @supports (-webkit-touch-callout: none) {
            body {
                /* iOS Safari 100vh fix */
                height: -webkit-fill-available;
            }
            
            .btn {
                /* iOSæŒ‰é’®ä¼˜åŒ– */
                -webkit-tap-highlight-color: transparent;
            }
        }
    </style>
</head>
<body>
    <!-- åŠ è½½åŠ¨ç”» -->
    <div class="loading" id="loading">
        <div class="loading-content">
            <div class="spinner"></div>
            <h2 style="color: gold; margin-bottom: 10px;">æ­£åœ¨åŠ è½½...</h2>
            <p style="color: #90EE90;">è¯·ç¨å€™</p>
        </div>
    </div>
    
    <!-- ä¸»å®¹å™¨ -->
    <div class="container">
        <canvas id="canvas"></canvas>
        
        <!-- æ ‡é¢˜ -->
        <div class="title">
            <h1>âœ¨ åœ£è¯å¿«ä¹ âœ¨</h1>
            <p>ç²’å­ä»å±å¹•è¾¹ç¼˜é£å‘åœ£è¯æ ‘å½¢çŠ¶</p>
        </div>
        
        <!-- ç¥ç¦è¯­ -->
        <div class="message" id="message">
            ğŸ… åœ£è¯å¿«ä¹ï¼æ„¿ä½ çš„ä¸–ç•Œå……æ»¡å¥‡è¿¹ï¼ ğŸ„
        </div>
        
        <!-- è®¡æ•°å™¨ -->
        <div class="counter">
            ç²’å­æ•°é‡: <span id="particleCount">0</span>
            <br>
            FPS: <span id="fpsCounter">0</span>
        </div>
        
        <!-- ä¿¡æ¯é¢æ¿ -->
        <div class="tree-info">
            <h3>ğŸ„ åœ£è¯æ ‘ä¿¡æ¯ ğŸ„</h3>
            <ul>
                <li>ç²’å­æ€»æ•°: <span id="infoCount">0</span></li>
                <li>å½“å‰ç±»å‹: <span id="infoType">åŸºç¡€åœ£è¯æ ‘</span></li>
                <li>ç‰©ç†æ•ˆæœ: <span id="infoPhysics">å¼€å¯</span></li>
                <li>è¿è¡Œæ—¶é—´: <span id="infoTime">0</span>ç§’</li>
            </ul>
        </div>
        
        <!-- æ§åˆ¶é¢æ¿ -->
        <button class="toggle-controls" onclick="toggleControls()">â–² éšè—æ§åˆ¶é¢æ¿</button>
        
        <div class="controls" id="controlsPanel">
            <div style="width: 100%; text-align: center; margin-bottom: 10px; color: gold;">
                é€‰æ‹©åœ£è¯æ ‘ç±»å‹:
            </div>
            <button class="btn active" onclick="changeTreeType('basic')">ğŸŒ² åŸºç¡€åœ£è¯æ ‘</button>
            <button class="btn" onclick="changeTreeType('spiral')">ğŸŒ€ èºæ—‹åœ£è¯æ ‘</button>
            <button class="btn" onclick="changeTreeType('heart')">â¤ï¸ å¿ƒå½¢åœ£è¯æ ‘</button>
            <button class="btn" onclick="changeTreeType('fractal')">ğŸŒ¿ åˆ†å½¢åœ£è¯æ ‘</button>
            <button class="btn" onclick="changeTreeType('star')">â­ æ˜Ÿå½¢åœ£è¯æ ‘</button>
            
            <div style="width: 100%; text-align: center; margin: 10px 0; color: cyan;">
                äº¤äº’æ§åˆ¶:
            </div>
            <button class="btn" onclick="addMoreParticles()">â• æ·»åŠ ç²’å­</button>
            <button class="btn" onclick="removeParticles()">â– å‡å°‘ç²’å­</button>
            <button class="btn" onclick="togglePhysics()">âš›ï¸ åˆ‡æ¢ç‰©ç†æ•ˆæœ</button>
            <button class="btn" onclick="toggleTrails()">âœ¨ åˆ‡æ¢æ‹–å°¾æ•ˆæœ</button>
            <button class="btn" onclick="explodeTree()">ğŸ’¥ çˆ†ç‚¸æ•ˆæœ</button>
            <button class="btn" onclick="resetTree()">ğŸ”„ é‡ç½®åœ£è¯æ ‘</button>
            
            <div style="width: 100%; text-align: center; margin: 10px 0; color: #FFD700;">
                è§†è§‰è®¾ç½®:
            </div>
            <button class="btn" onclick="changeSpeed('faster')">âš¡ åŠ å¿«é€Ÿåº¦</button>
            <button class="btn" onclick="changeSpeed('slower')">ğŸŒ å‡æ…¢é€Ÿåº¦</button>
            <button class="btn" onclick="toggleBackground()">ğŸŒŒ åˆ‡æ¢èƒŒæ™¯</button>
            <button class="btn" onclick="changeColorMode()">ğŸ¨ æ”¹å˜é¢œè‰²æ¨¡å¼</button>
        </div>
    </div>
    
    <script>
        // è®¾å¤‡æ£€æµ‹
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
        const isAndroid = /Android/.test(navigator.userAgent);
        
        // éšè—åŠ è½½ç•Œé¢
        setTimeout(() => {
            const loading = document.getElementById('loading');
            if (loading) {
                loading.style.opacity = '0';
                setTimeout(() => {
                    loading.style.display = 'none';
                }, 500);
            }
        }, 1000);
        
        // è·å–Canvaså’Œä¸Šä¸‹æ–‡
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        // è®¾ç½®Canvaså¤§å°
        function resizeCanvas() {
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            
            canvas.width = Math.floor(rect.width * dpr);
            canvas.height = Math.floor(rect.height * dpr);
            
            canvas.style.width = rect.width + 'px';
            canvas.style.height = rect.height + 'px';
            
            ctx.scale(dpr, dpr);
        }
        
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        window.addEventListener('orientationchange', function() {
            setTimeout(resizeCanvas, 150);
        });
        
        // ç²’å­æ•°ç»„å’Œè®¾ç½®
        let particles = [];
        let physicsEnabled = true;
        let trailsEnabled = true;
        let treeType = 'basic';
        let startTime = Date.now();
        let messageIndex = 0;
        let particleSpeed = 0.03;
        let darkBackground = true;
        let colorMode = 'christmas';
        let fps = 0;
        let frameCount = 0;
        let lastTime = Date.now();
        let isTouching = false;
        
        const messages = [
            "ğŸ… åœ£è¯å¿«ä¹ï¼æ„¿ä½ çš„ä¸–ç•Œå……æ»¡å¥‡è¿¹ï¼ ğŸ„",
            "âœ¨ æ„¿ä½ çš„ç”Ÿæ´»åƒè¿™æ£µåœ£è¯æ ‘ä¸€æ ·é—ªè€€ âœ¨",
            "ğŸ ç¥ä½ æ”¶åˆ°æœ€æƒ³è¦çš„ç¤¼ç‰©ï¼ ğŸ",
            "â„ï¸ æ„¿é›ªèŠ±å¸¦ç»™ä½ å¹³å®‰å’Œå–œæ‚¦ â„ï¸",
            "ğŸŒŸ æ–°çš„ä¸€å¹´ï¼Œæ–°çš„å¼€å§‹ï¼ ğŸŒŸ",
            "ğŸ’ çˆ±å’Œç¥ç¦ä¸ä½ åŒåœ¨ï¼ ğŸ’"
        ];
        
        // é¢œè‰²æ¨¡å¼
        const colorModes = {
            'christmas': {
                tree: ['#006400', '#228B22', '#32CD32', '#90EE90'],
                ornaments: ['#FF0000', '#0000FF', '#FFFF00', '#FF00FF', '#FFA500'],
                trunk: '#8B4513',
                star: 'gold'
            },
            'rainbow': {
                tree: ['#FF0000', '#FF7F00', '#FFFF00', '#00FF00', '#0000FF', '#4B0082', '#8B00FF'],
                ornaments: ['#FFFFFF', '#FF69B4', '#00FFFF', '#FFD700', '#FF1493'],
                trunk: '#A0522D',
                star: '#FFFFFF'
            },
            'winter': {
                tree: ['#E0F7FA', '#B2EBF2', '#80DEEA', '#4DD0E1'],
                ornaments: ['#FF8A80', '#FFD180', '#FFFF8D', '#80D8FF', '#EA80FC'],
                trunk: '#BCAAA4',
                star: '#FFF59D'
            },
            'neon': {
                tree: ['#FF00FF', '#00FFFF', '#00FF00', '#FFFF00'],
                ornaments: ['#FF0000', '#00FF00', '#0000FF', '#FFFFFF'],
                trunk: '#FF00FF',
                star: '#FFFFFF'
            }
        };
        
        // æ”¹å˜ç¥ç¦è¯­
        setInterval(() => {
            messageIndex = (messageIndex + 1) % messages.length;
            document.getElementById('message').textContent = messages[messageIndex];
        }, 5000);
        
        // æ›´æ–°ä¿¡æ¯é¢æ¿
        function updateInfo() {
            document.getElementById('infoCount').textContent = particles.length;
            document.getElementById('infoType').textContent = getTreeTypeName(treeType);
            document.getElementById('infoPhysics').textContent = physicsEnabled ? 'å¼€å¯' : 'å…³é—­';
            document.getElementById('infoTime').textContent = Math.floor((Date.now() - startTime) / 1000);
            document.getElementById('particleCount').textContent = particles.length;
        }
        
        // ç²’å­ç±»
        class Particle {
            constructor(x, y, targetX, targetY, color, size, speed) {
                this.x = x;
                this.y = y;
                this.originalX = x;
                this.originalY = y;
                this.targetX = targetX;
                this.targetY = targetY;
                this.color = color;
                this.size = size || Math.random() * 2 + 1;
                this.speed = speed || particleSpeed;
                this.velocity = {
                    x: (Math.random() - 0.5) * 2,
                    y: (Math.random() - 0.5) * 2
                };
                this.friction = 0.95;
                this.attraction = 0.1;
                this.distance = Math.sqrt(
                    Math.pow(targetX - x, 2) + Math.pow(targetY - y, 2)
                );
                this.trail = [];
                this.maxTrail = 5;
            }
            
            update() {
                // ä¿å­˜è½¨è¿¹
                if (trailsEnabled) {
                    this.trail.push({x: this.x, y: this.y});
                    if (this.trail.length > this.maxTrail) {
                        this.trail.shift();
                    }
                }
                
                // è®¡ç®—ç›®æ ‡æ–¹å‘
                const dx = this.targetX - this.x;
                const dy = this.targetY - this.y;
                
                if (physicsEnabled) {
                    // ç‰©ç†æ•ˆæœï¼šå‘ç›®æ ‡ç§»åŠ¨
                    this.velocity.x += dx * this.attraction * this.speed;
                    this.velocity.y += dy * this.attraction * this.speed;
                    
                    // æ‘©æ“¦åŠ›
                    this.velocity.x *= this.friction;
                    this.velocity.y *= this.friction;
                    
                    // æ›´æ–°ä½ç½®
                    this.x += this.velocity.x;
                    this.y += this.velocity.y;
                    
                    // æ·»åŠ éšæœºè¿åŠ¨
                    this.x += (Math.random() - 0.5) * 0.3;
                    this.y += (Math.random() - 0.5) * 0.3;
                } else {
                    // ç›´æ¥å‘ç›®æ ‡ç§»åŠ¨
                    this.x += dx * this.speed;
                    this.y += dy * this.speed;
                }
                
                // è·ç¦»ç›®æ ‡å¾ˆè¿‘æ—¶ï¼Œå‡é€Ÿ
                const currentDistance = Math.sqrt(dx * dx + dy * dy);
                if (currentDistance < 1) {
                    this.x = this.targetX;
                    this.y = this.targetY;
                }
            }
            
            draw() {
                // ç»˜åˆ¶è½¨è¿¹
                if (trailsEnabled && this.trail.length > 1) {
                    ctx.beginPath();
                    ctx.moveTo(this.trail[0].x, this.trail[0].y);
                    
                    for (let i = 1; i < this.trail.length; i++) {
                        ctx.lineTo(this.trail[i].x, this.trail[i].y);
                    }
                    
                    ctx.strokeStyle = this.color.replace(')', ', 0.3)').replace('rgb', 'rgba');
                    ctx.lineWidth = this.size / 2;
                    ctx.stroke();
                }
                
                // ç»˜åˆ¶ç²’å­
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
                
                // å‘å…‰æ•ˆæœ
                if (this.size > 1.5) {
                    ctx.shadowColor = this.color;
                    ctx.shadowBlur = 15;
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }
            }
        }
        
        // ç”ŸæˆåŸºç¡€åœ£è¯æ ‘ç²’å­
        function generateBasicTree() {
            particles = [];
            const dpr = window.devicePixelRatio || 1;
            const centerX = canvas.width / dpr / 2;
            const baseY = canvas.height / dpr * 0.65;
            const treeHeight = Math.min(canvas.width, canvas.height) / dpr * 0.35;
            
            const colors = colorModes[colorMode];
            
            // ç»¿è‰²ç²’å­ï¼ˆæ ‘å† ï¼‰
            const layerCount = 5;
            
            for (let layer = 0; layer < layerCount; layer++) {
                const layerHeight = treeHeight * (1 - layer / layerCount);
                const layerWidth = (layer + 1) * 25;
                const particleCount = 40 + layer * 15;
                
                for (let i = 0; i < particleCount; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const radius = Math.random() * layerWidth;
                    const x = centerX + Math.cos(angle) * radius;
                    const y = baseY - layerHeight + Math.sin(angle) * (layerHeight / 4);
                    
                    const color = colors.tree[Math.floor(Math.random() * colors.tree.length)];
                    const size = Math.random() * 2 + 0.5;
                    
                    particles.push(new Particle(
                        Math.random() * canvas.width / dpr,
                        Math.random() * canvas.height / dpr,
                        x, y, color, size
                    ));
                }
            }
            
            // è£…é¥°çƒç²’å­
            for (let i = 0; i < 25; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * 80;
                const x = centerX + Math.cos(angle) * radius;
                const y = baseY - treeHeight * 0.5 + Math.sin(angle) * 40;
                
                const color = colors.ornaments[Math.floor(Math.random() * colors.ornaments.length)];
                const size = Math.random() * 3 + 1.5;
                
                particles.push(new Particle(
                    Math.random() * canvas.width / dpr,
                    Math.random() * canvas.height / dpr,
                    x, y, color, size, particleSpeed * 1.5
                ));
            }
            
            // æ˜Ÿæ˜Ÿç²’å­
            for (let i = 0; i < 15; i++) {
                const x = centerX + (Math.random() - 0.5) * 30;
                const y = baseY - treeHeight - 15;
                
                particles.push(new Particle(
                    Math.random() * canvas.width / dpr,
                    Math.random() * canvas.height / dpr,
                    x, y, colors.star, Math.random() * 3 + 1.5, particleSpeed * 2
                ));
            }
            
            // æ ‘å¹²ç²’å­
            for (let i = 0; i < 40; i++) {
                const x = centerX + (Math.random() - 0.5) * 30;
                const y = baseY + (Math.random() - 0.5) * 50;
                
                particles.push(new Particle(
                    Math.random() * canvas.width / dpr,
                    Math.random() * canvas.height / dpr,
                    x, y, colors.trunk, Math.random() * 2 + 1
                ));
            }
            
            updateInfo();
        }
        
        // ç”Ÿæˆèºæ—‹åœ£è¯æ ‘
        function generateSpiralTree() {
            particles = [];
            const dpr = window.devicePixelRatio || 1;
            const centerX = canvas.width / dpr / 2;
            const baseY = canvas.height / dpr * 0.6;
            const height = Math.min(canvas.width, canvas.height) / dpr * 0.4;
            
            const colors = colorModes[colorMode];
            const spiralCount = 3;
            
            for (let spiral = 0; spiral < spiralCount; spiral++) {
                const turns = 4;
                const points = 150;
                const spiralRadius = 40 + spiral * 25;
                
                for (let i = 0; i < points; i++) {
                    const t = i / points * turns * Math.PI * 2;
                    const radius = (t / (turns * Math.PI * 2)) * spiralRadius;
                    const yOffset = (t / (turns * Math.PI * 2)) * height;
                    
                    const x = centerX + Math.cos(t) * radius;
                    const y = baseY - yOffset + Math.sin(t) * radius * 0.3;
                    
                    const colorIndex = Math.floor((i / points) * colors.tree.length);
                    const color = colors.tree[colorIndex % colors.tree.length];
                    
                    particles.push(new Particle(
                        Math.random() * canvas.width / dpr,
                        Math.random() * canvas.height / dpr,
                        x, y, color, Math.random() * 1.5 + 1
                    ));
                }
            }
            
            // æ·»åŠ è£…é¥°
            addRandomDecorations(centerX, baseY, height);
            updateInfo();
        }
        
        // ç”Ÿæˆå¿ƒå½¢åœ£è¯æ ‘
        function generateHeartTree() {
            particles = [];
            const dpr = window.devicePixelRatio || 1;
            const centerX = canvas.width / dpr / 2;
            const centerY = canvas.height / dpr * 0.6;
            const scale = Math.min(canvas.width, canvas.height) / dpr * 0.25;
            
            const colors = colorModes[colorMode];
            
            // å¿ƒå½¢æ›²çº¿æ–¹ç¨‹
            const points = 400;
            for (let i = 0; i < points; i++) {
                const t = i / points * Math.PI * 2;
                const x = 16 * Math.pow(Math.sin(t), 3);
                const y = -(13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t));
                
                const particleX = centerX + x * scale / 16;
                const particleY = centerY + y * scale / 16;
                
                // æ ¹æ®ä½ç½®é€‰æ‹©é¢œè‰²
                let color;
                if (particleY < centerY - scale * 0.5) {
                    color = colors.star;
                } else if (particleY < centerY - scale * 0.2) {
                    color = colors.ornaments[Math.floor(Math.random() * colors.ornaments.length)];
                } else {
                    const colorIndex = Math.floor((i / points) * colors.tree.length);
                    color = colors.tree[colorIndex % colors.tree.length];
                }
                
                particles.push(new Particle(
                    Math.random() * canvas.width / dpr,
                    Math.random() * canvas.height / dpr,
                    particleX, particleY, color, Math.random() * 1.5 + 1
                ));
            }
            
            updateInfo();
        }
        
        // ç”Ÿæˆåˆ†å½¢åœ£è¯æ ‘
        function generateFractalTree() {
            particles = [];
            const dpr = window.devicePixelRatio || 1;
            const startX = canvas.width / dpr / 2;
            const startY = canvas.height / dpr * 0.75;
            
            const colors = colorModes[colorMode];
            
            // é€’å½’ç»˜åˆ¶åˆ†å½¢æ ‘
            function drawBranch(x, y, length, angle, depth, maxDepth) {
                if (depth > maxDepth) return;
                
                const endX = x + Math.cos(angle) * length;
                const endY = y + Math.sin(angle) * length;
                
                // æ·»åŠ æ ‘æç²’å­
                const segmentCount = Math.floor(length / 4);
                for (let i = 0; i <= segmentCount; i++) {
                    const t = i / segmentCount;
                    const particleX = x + (endX - x) * t;
                    const particleY = y + (endY - y) * t;
                    
                    const color = depth === 0 ? colors.trunk : colors.tree[depth % colors.tree.length];
                    const size = (maxDepth - depth + 1) * 1.2;
                    
                    particles.push(new Particle(
                        Math.random() * canvas.width / dpr,
                        Math.random() * canvas.height / dpr,
                        particleX, particleY, color, size, particleSpeed
                    ));
                }
                
                // é€’å½’ç»˜åˆ¶å·¦å³åˆ†æ”¯
                const newLength = length * 0.7;
                drawBranch(endX, endY, newLength, angle - Math.PI/5, depth + 1, maxDepth);
                drawBranch(endX, endY, newLength, angle + Math.PI/5, depth + 1, maxDepth);
                
                // æ·»åŠ è£…é¥°çƒ
                if (depth >= 2 && Math.random() < 0.4) {
                    const decorX = x + (endX - x) * 0.6;
                    const decorY = y + (endY - y) * 0.6;
                    const decorColor = colors.ornaments[Math.floor(Math.random() * colors.ornaments.length)];
                    
                    for (let j = 0; j < 3; j++) {
                        particles.push(new Particle(
                            Math.random() * canvas.width / dpr,
                            Math.random() * canvas.height / dpr,
                            decorX + (Math.random() - 0.5) * 15,
                            decorY + (Math.random() - 0.5) * 15,
                            decorColor, Math.random() * 2 + 1, particleSpeed * 1.5
                        ));
                    }
                }
            }
            
            drawBranch(startX, startY, 120, -Math.PI/2, 0, 5);
            updateInfo();
        }
        
        // ç”Ÿæˆæ˜Ÿå½¢åœ£è¯æ ‘
        function generateStarTree() {
            particles = [];
            const dpr = window.devicePixelRatio || 1;
            const centerX = canvas.width / dpr / 2;
            const centerY = canvas.height / dpr * 0.6;
            const radius = Math.min(canvas.width, canvas.height) / dpr * 0.25;
            
            const colors = colorModes[colorMode];
            
            // åˆ›å»ºæ˜Ÿå½¢
            const points = 5;
            const spikes = 5;
            
            for (let star = 0; star < 3; star++) {
                const currentRadius = radius * (1 - star * 0.3);
                const angleStep = Math.PI * 2 / points;
                
                for (let i = 0; i < points * 2; i++) {
                    const angle = i * angleStep / 2;
                    const r = i % 2 === 0 ? currentRadius : currentRadius * 0.5;
                    
                    const x = centerX + Math.cos(angle) * r;
                    const y = centerY + Math.sin(angle) * r;
                    
                    const colorIndex = Math.floor((i / (points * 2)) * colors.tree.length);
                    const color = colors.tree[colorIndex % colors.tree.length];
                    
                    particles.push(new Particle(
                        Math.random() * canvas.width / dpr,
                        Math.random() * canvas.height / dpr,
                        x, y, color, Math.random() * 2 + 1
                    ));
                }
            }
            
            // ä¸­å¿ƒè£…é¥°
            for (let i = 0; i < 20; i++) {
                const angle = Math.random() * Math.PI * 2;
                const r = Math.random() * 40;
                
                particles.push(new Particle(
                    Math.random() * canvas.width / dpr,
                    Math.random() * canvas.height / dpr,
                    centerX + Math.cos(angle) * r,
                    centerY + Math.sin(angle) * r,
                    colors.star, Math.random() * 3 + 1.5, particleSpeed * 2
                ));
            }
            
            updateInfo();
        }
        
        // æ·»åŠ éšæœºè£…é¥°
        function addRandomDecorations(centerX, centerY, height) {
            const colors = colorModes[colorMode];
            
            for (let i = 0; i < 20; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * 60;
                const x = centerX + Math.cos(angle) * radius;
                const y = centerY - height * 0.3 + Math.sin(angle) * 30;
                
                particles.push(new Particle(
                    Math.random() * canvas.width / (window.devicePixelRatio || 1),
                    Math.random() * canvas.height / (window.devicePixelRatio || 1),
                    x, y, 
                    colors.ornaments[Math.floor(Math.random() * colors.ornaments.length)],
                    Math.random() * 2.5 + 1.5,
                    particleSpeed * 1.5
                ));
            }
        }
        
        // æ”¹å˜åœ£è¯æ ‘ç±»å‹
        function changeTreeType(type) {
            treeType = type;
            
            // æ›´æ–°æŒ‰é’®çŠ¶æ€
            document.querySelectorAll('.btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // æ‰¾åˆ°å¹¶æ¿€æ´»å¯¹åº”çš„æŒ‰é’®
            const buttons = document.querySelectorAll('.btn');
            const buttonText = {
                'basic': 'ğŸŒ² åŸºç¡€åœ£è¯æ ‘',
                'spiral': 'ğŸŒ€ èºæ—‹åœ£è¯æ ‘',
                'heart': 'â¤ï¸ å¿ƒå½¢åœ£è¯æ ‘',
                'fractal': 'ğŸŒ¿ åˆ†å½¢åœ£è¯æ ‘',
                'star': 'â­ æ˜Ÿå½¢åœ£è¯æ ‘'
            }[type];
            
            buttons.forEach(btn => {
                if (btn.textContent === buttonText) {
                    btn.classList.add('active');
                }
            });
            
            // ç”Ÿæˆæ–°æ ‘
            switch(type) {
                case 'basic':
                    generateBasicTree();
                    break;
                case 'spiral':
                    generateSpiralTree();
                    break;
                case 'heart':
                    generateHeartTree();
                    break;
                case 'fractal':
                    generateFractalTree();
                    break;
                case 'star':
                    generateStarTree();
                    break;
            }
            
            updateInfo();
        }
        
        // è·å–åœ£è¯æ ‘ç±»å‹åç§°
        function getTreeTypeName(type) {
            const names = {
                'basic': 'åŸºç¡€åœ£è¯æ ‘',
                'spiral': 'èºæ—‹åœ£è¯æ ‘',
                'heart': 'å¿ƒå½¢åœ£è¯æ ‘',
                'fractal': 'åˆ†å½¢åœ£è¯æ ‘',
                'star': 'æ˜Ÿå½¢åœ£è¯æ ‘'
            };
            return names[type] || 'æœªçŸ¥ç±»å‹';
        }
        
        // æ·»åŠ æ›´å¤šç²’å­
        function addMoreParticles() {
            const dpr = window.devicePixelRatio || 1;
            const centerX = canvas.width / dpr / 2;
            const centerY = canvas.height / dpr * 0.5;
            const colors = colorModes[colorMode];
            
            for (let i = 0; i < 50; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * 150;
                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;
                
                const color = Math.random() > 0.5 
                    ? colors.tree[Math.floor(Math.random() * colors.tree.length)]
                    : colors.ornaments[Math.floor(Math.random() * colors.ornaments.length)];
                
                particles.push(new Particle(
                    Math.random() * canvas.width / dpr,
                    Math.random() * canvas.height / dpr,
                    x, y, color, Math.random() * 2 + 1, particleSpeed
                ));
            }
            
            updateInfo();
        }
        
        // å‡å°‘ç²’å­
        function removeParticles() {
            if (particles.length > 100) {
                particles.splice(0, 50);
                updateInfo();
            }
        }
        
        // åˆ‡æ¢ç‰©ç†æ•ˆæœ
        function togglePhysics() {
            physicsEnabled = !physicsEnabled;
            const btn = event.target;
            btn.textContent = physicsEnabled ? 'âš›ï¸ å…³é—­ç‰©ç†æ•ˆæœ' : 'âš›ï¸ å¼€å¯ç‰©ç†æ•ˆæœ';
            updateInfo();
        }
        
        // åˆ‡æ¢æ‹–å°¾æ•ˆæœ
        function toggleTrails() {
            trailsEnabled = !trailsEnabled;
            const btn = event.target;
            btn.textContent = trailsEnabled ? 'âœ¨ å…³é—­æ‹–å°¾æ•ˆæœ' : 'âœ¨ å¼€å¯æ‹–å°¾æ•ˆæœ';
        }
        
        // åˆ‡æ¢èƒŒæ™¯
        function toggleBackground() {
            darkBackground = !darkBackground;
            const btn = event.target;
            btn.textContent = darkBackground ? 'ğŸŒŒ åˆ‡æ¢äº®è‰²èƒŒæ™¯' : 'ğŸŒŒ åˆ‡æ¢æ·±è‰²èƒŒæ™¯';
        }
        
        // æ”¹å˜é¢œè‰²æ¨¡å¼
        function changeColorMode() {
            const modes = Object.keys(colorModes);
            const currentIndex = modes.indexOf(colorMode);
            colorMode = modes[(currentIndex + 1) % modes.length];
            
            const btn = event.target;
            btn.textContent = `ğŸ¨ ${colorMode.charAt(0).toUpperCase() + colorMode.slice(1)}æ¨¡å¼`;
            
            // é‡æ–°ç”Ÿæˆå½“å‰æ ‘
            changeTreeType(treeType);
        }
        
        // æ”¹å˜é€Ÿåº¦
        function changeSpeed(type) {
            if (type === 'faster') {
                particleSpeed = Math.min(particleSpeed * 1.5, 0.1);
            } else {
                particleSpeed = Math.max(particleSpeed / 1.5, 0.005);
            }
            
            // æ›´æ–°æ‰€æœ‰ç²’å­çš„é€Ÿåº¦
            particles.forEach(particle => {
                particle.speed = particleSpeed;
            });
        }
        
        // çˆ†ç‚¸æ•ˆæœ
        function explodeTree() {
            particles.forEach(particle => {
                const angle = Math.random() * Math.PI * 2;
                const force = Math.random() * 8 + 3;
                
                particle.targetX = particle.x + Math.cos(angle) * force * 40;
                particle.targetY = particle.y + Math.sin(angle) * force * 40;
                particle.speed = Math.random() * 0.08 + 0.03;
            });
            
            setTimeout(() => {
                changeTreeType(treeType);
            }, 1200);
        }
        
        // é‡ç½®åœ£è¯æ ‘
        function resetTree() {
            particleSpeed = 0.03;
            trailsEnabled = true;
            physicsEnabled = true;
            darkBackground = true;
            colorMode = 'christmas';
            changeTreeType('basic');
            
            // é‡ç½®æŒ‰é’®æ–‡å­—
            document.querySelectorAll('.btn').forEach(btn => {
                if (btn.textContent.includes('ç‰©ç†æ•ˆæœ')) btn.textContent = 'âš›ï¸ åˆ‡æ¢ç‰©ç†æ•ˆæœ';
                if (btn.textContent.includes('æ‹–å°¾æ•ˆæœ')) btn.textContent = 'âœ¨ åˆ‡æ¢æ‹–å°¾æ•ˆæœ';
                if (btn.textContent.includes('èƒŒæ™¯')) btn.textContent = 'ğŸŒŒ åˆ‡æ¢èƒŒæ™¯';
                if (btn.textContent.includes('é¢œè‰²æ¨¡å¼')) btn.textContent = 'ğŸ¨ æ”¹å˜é¢œè‰²æ¨¡å¼';
            });
        }
        
        // åˆ‡æ¢æ§åˆ¶é¢æ¿æ˜¾ç¤º
        function toggleControls() {
            const panel = document.getElementById('controlsPanel');
            const toggleBtn = document.querySelector('.toggle-controls');
            
            if (panel.style.display === 'none') {
                panel.style.display = 'flex';
                toggleBtn.textContent = 'â–² éšè—æ§åˆ¶é¢æ¿';
            } else {
                panel.style.display = 'none';
                toggleBtn.textContent = 'â–¼ æ˜¾ç¤ºæ§åˆ¶é¢æ¿';
            }
        }
        
        // åŠ¨ç”»å¾ªç¯
        function animate(timestamp) {
            // è®¡ç®—FPS
            frameCount++;
            if (!lastTime) lastTime = timestamp;
            if (timestamp - lastTime >= 1000) {
                fps = frameCount;
                frameCount = 0;
                lastTime = timestamp;
                document.getElementById('fpsCounter').textContent = fps;
            }
            
            // æ¸…ç©ºç”»å¸ƒ
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // ç»˜åˆ¶èƒŒæ™¯
            if (darkBackground) {
                // æ·±è‰²æ˜Ÿç©ºèƒŒæ™¯
                const dpr = window.devicePixelRatio || 1;
                const gradient = ctx.createRadialGradient(
                    canvas.width / dpr / 2,
                    canvas.height / dpr / 2,
                    0,
                    canvas.width / dpr / 2,
                    canvas.height / dpr / 2,
                    Math.max(canvas.width, canvas.height) / dpr / 2
                );
                gradient.addColorStop(0, 'rgba(10, 31, 61, 0.3)');
                gradient.addColorStop(1, 'rgba(0, 0, 0, 0.9)');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width / dpr, canvas.height / dpr);
                
                // ç»˜åˆ¶ä¸€äº›æ˜Ÿæ˜Ÿ
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                for (let i = 0; i < 30; i++) {
                    const x = (i * 37) % (canvas.width / dpr);
                    const y = (i * 23) % (canvas.height / dpr);
                    const size = Math.sin(Date.now() / 1000 + i) * 0.5 + 1;
                    ctx.beginPath();
                    ctx.arc(x, y, size, 0, Math.PI * 2);
                    ctx.fill();
                }
            } else {
                // äº®è‰²èƒŒæ™¯
                const dpr = window.devicePixelRatio || 1;
                const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height / dpr);
                gradient.addColorStop(0, '#87CEEB');
                gradient.addColorStop(1, '#E0F7FF');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width / dpr, canvas.height / dpr);
            }
            
            // æ›´æ–°å’Œç»˜åˆ¶æ‰€æœ‰ç²’å­
            particles.forEach(particle => {
                particle.update();
                particle.draw();
                
                // ç²’å­é—´çš„è¿çº¿ï¼ˆåªåœ¨ç‰©ç†å¼€å¯æ—¶ï¼‰
                if (physicsEnabled && particles.length < 1000) {
                    particles.forEach(otherParticle => {
                        if (particle === otherParticle) return;
                        
                        const dx = particle.x - otherParticle.x;
                        const dy = particle.y - otherParticle.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < 40 && distance > 5) {
                            ctx.beginPath();
                            const alpha = 0.1 * (1 - distance/40);
                            ctx.strokeStyle = `rgba(255, 255, 255, ${alpha})`;
                            ctx.lineWidth = 0.3;
                            ctx.moveTo(particle.x, particle.y);
                            ctx.lineTo(otherParticle.x, otherParticle.y);
                            ctx.stroke();
                        }
                    });
                }
            });
            
            // æ›´æ–°è®¡æ•°å™¨
            document.getElementById('particleCount').textContent = particles.length;
            
            // ç»§ç»­åŠ¨ç”»
            requestAnimationFrame(animate);
        }
        
        // åˆå§‹åŒ–è§¦æ‘¸äº‹ä»¶
        function initTouchEvents() {
            if (!canvas) return;
            
            canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
            canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
            canvas.addEventListener('touchend', handleTouchEnd, { passive: false });
            
            // é¼ æ ‡äº‹ä»¶ï¼ˆæ¡Œé¢ç«¯æ”¯æŒï¼‰
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('mouseleave', handleMouseUp);
            
            console.log('è§¦æ‘¸äº‹ä»¶åˆå§‹åŒ–å®Œæˆ');
        }
        
        function handleTouchStart(e) {
            e.preventDefault();
            isTouching = true;
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            
            const touchX = (touch.clientX - rect.left) * dpr;
            const touchY = (touch.clientY - rect.top) * dpr;
            
            // æ·»åŠ è§¦æ‘¸ç‚¹æ•ˆæœ
            addTouchEffect(touchX / dpr, touchY / dpr);
        }
        
        function handleTouchMove(e) {
            e.preventDefault();
            if (!isTouching) return;
            
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            
            const touchX = (touch.clientX - rect.left) * dpr;
            const touchY = (touch.clientY - rect.top) * dpr;
            
            // å½±å“ç²’å­
            particles.forEach(particle => {
                const dx = particle.x - touchX / dpr;
                const dy = particle.y - touchY / dpr;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < 100 && physicsEnabled) {
                    const force = (100 - distance) / 100 * 1.5;
                    const angle = Math.atan2(dy, dx);
                    
                    particle.velocity.x += Math.cos(angle) * force * 2;
                    particle.velocity.y += Math.sin(angle) * force * 2;
                }
            });
        }
        
        function handleTouchEnd(e) {
            e.preventDefault();
            isTouching = false;
        }
        
        function handleMouseDown(e) {
            isTouching = true;
            const rect = canvas.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            
            const mouseX = (e.clientX - rect.left) * dpr;
            const mouseY = (e.clientY - rect.top) * dpr;
            
            addTouchEffect(mouseX / dpr, mouseY / dpr);
        }
        
        function handleMouseMove(e) {
            if (!isTouching || e.buttons !== 1) return;
            
            const rect = canvas.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            
            const mouseX = (e.clientX - rect.left) * dpr;
            const mouseY = (e.clientY - rect.top) * dpr;
            
            particles.forEach(particle => {
                const dx = particle.x - mouseX / dpr;
                const dy = particle.y - mouseY / dpr;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < 100 && physicsEnabled) {
                    const force = (100 - distance) / 100;
                    const angle = Math.atan2(dy, dx);
                    
                    particle.velocity.x += Math.cos(angle) * force * 1.5;
                    particle.velocity.y += Math.sin(angle) * force * 1.5;
                }
            });
        }
        
        function handleMouseUp() {
            isTouching = false;
        }
        
        // æ·»åŠ è§¦æ‘¸ç‚¹æ•ˆæœ
        function addTouchEffect(x, y) {
            const colors = colorModes[colorMode];
            const colorList = colors.ornaments.concat(colors.tree);
            
            for (let i = 0; i < 5; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * 20;
                const color = colorList[Math.floor(Math.random() * colorList.length)];
                
                particles.push(new Particle(
                    x, y,
                    x + Math.cos(angle) * radius,
                    y + Math.sin(angle) * radius,
                    color, Math.random() * 1.5 + 1, 0.05
                ));
            }
            
            updateInfo();
        }
        
        // é˜²æ­¢é¡µé¢æ»šåŠ¨
        document.addEventListener('touchmove', function(e) {
            if (e.target.tagName !== 'CANVAS') {
                e.preventDefault();
            }
        }, { passive: false });
        
        // é˜²æ­¢åŒå‡»ç¼©æ”¾
        let lastTouchEnd = 0;
        document.addEventListener('touchend', function(e) {
            const now = Date.now();
            if (now - lastTouchEnd <= 300) {
                e.preventDefault();
            }
            lastTouchEnd = now;
        }, false);
        
        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        window.addEventListener('load', function() {
            // åˆå§‹åŒ–åœ£è¯æ ‘
            generateBasicTree();
            
            // åˆå§‹åŒ–è§¦æ‘¸äº‹ä»¶
            initTouchEvents();
            
            // å¼€å§‹åŠ¨ç”»
            animate();
            updateInfo();
            
            // æ¯ç§’æ›´æ–°ä¸€æ¬¡ä¿¡æ¯
            setInterval(updateInfo, 1000);
        });
        
        // é¡µé¢å¯è§æ€§å˜åŒ–å¤„ç†
        document.addEventListener('visibilitychange', function() {
            if (document.hidden) {
                // é¡µé¢éšè—æ—¶æš‚åœåŠ¨ç”»
                cancelAnimationFrame(animate);
            } else {
                // é¡µé¢æ˜¾ç¤ºæ—¶æ¢å¤åŠ¨ç”»
                animate();
            }
        });
    </script>
</body>
</html>